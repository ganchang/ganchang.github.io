(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{167:function(t,e,a){},210:function(t,e,a){"use strict";var s=a(167);a.n(s).a},288:function(t,e,a){"use strict";a.r(e);var s=[{excerpt:"<p>常用 Markdown 语法测试。</p>\n",tags:["markdown"],id:0,title:"测试 Markdown",lastUpdated:"2018-04-29 12:15:53",path:"/posts/test-markdown.html"},{excerpt:"<blockquote>\n<p>记录我在使用 Vue 中发现的一些好的代码实践，希望能够保持更新。🤠</p>\n</blockquote>\n",tags:["Vue","技巧"],id:1,title:"Vue最佳实践",lastUpdated:"2018-03-20 20:18:51",path:"/posts/vue-best-practices.html"},{excerpt:"<p>Vue 和 React 的大红大火，带来的是组件化和数据驱动的开发方式。Demo 很美好，但如果没有一定的实际开发经验积累，总是能把一个功能模块写成浆糊。\n依托于 Webpack 等构建工具，使得前端代码具备了后端编程语言的代码组织能力，摆脱了传统的「一泻而下」式的代码编写。至此，作为前端也该对自己的代码有更高的要求。</p>\n",tags:["前端","组件","Vue","React"],id:2,title:"编写良好的前端组件",lastUpdated:"2017-03-17 10:22:38",path:"/posts/write-good-front-end-component.html"},{excerpt:"<p>在数据操作时，Lodash 就是我的弹药库，不管遇到多复杂的数据结构都能用一些函数轻松拆解。</p>\n<p>ES6 中也新增了诸多新的对象函数，一些简单的项目中 ES6 就足够使用了，但还是会有例外的情况引用了少数的 Lodash 函数。一个完整的 Lodash 库，即使是压缩后，现最新版本也有 <code>71k</code> 的体积。不能为了吃一口饭而买下一个饭店啊。</p>\n<p>针对这个问题，其实已经有很多可选方案了。</p>\n",tags:["Webpack","Lodash"],id:3,title:"Webpack按需打包Lodash的几种方式",lastUpdated:"2016-12-17 01:41:21",path:"/posts/webpack-use-lodash.html"},{excerpt:"<p>在数据操作时，Lodash 就是我的弹药库，不管遇到多复杂的数据结构都能用一些函数轻松拆解。</p>\n<p>ES6 中也新增了诸多新的对象函数，一些简单的项目中 ES6 就足够使用了，但还是会有例外的情况引用了少数的 Lodash 函数。一个完整的 Lodash 库，即使是压缩后，现最新版本也有 <code>71k</code> 的体积。不能为了吃一口饭而买下一个饭店啊。</p>\n<p>针对这个问题，其实已经有很多可选方案了。</p>\n",tags:["Webpack","Lodash"],id:4,title:"Webpack按需打包Lodash的几种方式",lastUpdated:"2016-12-17 01:41:21",path:"/posts/webpack-use-lodash%20-%20%E5%89%AF%E6%9C%AC.html"},{excerpt:'<h2 id="前言"><a class="header-anchor" href="前言" aria-hidden="true"></a> 前言</h2>\n<p>在输入编辑的业务场景中，可能会需要在光标当前的位置或附近显示提示选项。比如社交评论中的<code>@user</code>功能，要确保提示的用户列表总是出现在<code>@</code>字符右下方，又或者是在自定义编辑器中 autocomplete 语法提示，都需要获取光标当前的位置作为参照点。</p>\n',tags:["JavaScript","Range","Selection"],id:5,title:"JavaScript 获取输入时的光标位置及场景问题",lastUpdated:"2016-11-25 10:02:01",path:"/posts/cursor-offset-at-input.html"},{excerpt:"<p>关于前端页面的文字溢出截断的招数已经很常见了。\n通常的实现有，前端css控制、后端字数输出控制或者前端js字数处理等。</p>\n",tags:["Html","CSS","Ellipsis"],id:6,title:"前端文字的截断处理",lastUpdated:"2015-09-06 17:37:32",path:"/posts/text-truncation.html"}],n={name:"Layout",data:function(){return{isHide:!1,needOverlay:!1,content:s}},methods:{clickMenu:function(){this.isHide=!this.isHide,"undefined"!=typeof window&&window.innerWidth<=1190&&(this.needOverlay=!this.needOverlay)},close:function(){this.needOverlay=!this.needOverlay,this.isHide=!this.isHide}}},i=(a(210),a(17)),o=Object(i.a)(n,(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticStyle:{height:"100%"}},[a("el-container",{staticClass:"main-container"},[a("my-aside",{attrs:{isHide:t.isHide}}),t._v(" "),a("el-container",{staticClass:"container-warp"},[a("my-header",{attrs:{showIcon:t.isHide},on:{clickMenu:t.clickMenu}},[t._v("\n        >")]),t._v(" "),a("my-main",{attrs:{isHide:t.isHide,content:t.content}})],1),t._v(" "),a("go-top")],1),t._v(" "),a("my-footer",{attrs:{content:t.content,isHide:t.isHide}}),t._v(" "),a("div",{staticClass:"overlay",class:{"overlay--active":t.needOverlay},on:{click:t.close}})],1)}),[],!1,null,"92ac3240",null);e.default=o.exports}}]);